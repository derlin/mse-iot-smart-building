#!/usr/bin/env python
# -*- coding: utf-8 -*-

import sys
import time
import logging
import configpi
import json

from louie import dispatcher
from datetime import datetime
from flask import jsonify
from collections import OrderedDict

from openzwave.network import ZWaveNetwork
from openzwave.option import ZWaveOption

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger('openzwave')

started = False
name = configpi.name



###########################################################################################################################
###########################################################################################################################
##########    Root parent backend class     ###############################################################################
###########################################################################################################################
###########################################################################################################################


class Backend():

    def __init__(self):

    ###################  instanciation de l'objet backend ########################################################


    ###### options needed for python openzwave library like config files path, logging,
        device = configpi.interface
        options = ZWaveOption(device, config_path="/home/pi/IoTLab/python-openzwave/openzwave/config", user_path=".", cmd_line="")
        options.set_log_file("OZW.log")
        options.set_append_log_file(False)
        options.set_console_output(False)
        options.set_save_log_level('Warning')
        options.set_logging(True)
        options.lock()

        # creation of the object network using the options entity already created
        self.network = ZWaveNetwork(options, autostart=False)

    ######   These dispatchers associate a method to a signal. the signals are generated by the library python-openzwave.
    ######   Once the signal is received. It's associated method is executed (see "_node_added" example below in "_network_started" method)
        dispatcher.connect(self._network_started, ZWaveNetwork.SIGNAL_NETWORK_STARTED)
        dispatcher.connect(self._network_ready, ZWaveNetwork.SIGNAL_NETWORK_READY)

    ###### backend object attributes
#        self.devices = OrderedDict()  ### will contain the list of nodes in the network
#        self.sensors = OrderedDict()  ### will contain the list of sensors (only) in the network
        self.node_added = False
        self.node_removed = False
        self.timestamps = {}          ### will contain the time of the last values' update for each sensor
        self.queryStages = {          ### the diffrent stages that a node object gets through before being ready
                "None"                  :  1, # Query process hasn't started for this node
                "ProtocolInfo"          :  2, # Retrieve protocol information
                "Probe"                 :  3, # Ping device to see if alive
                "WakeUp"                :  4, # Start wake up process if a sleeping node
                "ManufacturerSpecific1" :  5, # Retrieve manufacturer name and product ids if ProtocolInfo lets us
                "NodeInfo"              :  6, # Retrieve info about supported, controlled command classes
                "SecurityReport"        :  7, # Retrieve a list of Command Classes that require Security
                "ManufacturerSpecific2" :  8, # Retrieve manufacturer name and product ids
                "Versions"              :  9, # Retrieve version information
                "Instances"             : 10, # Retrieve information about multiple command class instances
                "Static"                : 11, # Retrieve static information (doesn't change)
                "Probe1"                : 12, # Ping a device upon starting with configuration
                "Associations"          : 13, # Retrieve information about associations
                "Neighbors"             : 14, # Retrieve node neighbor list
                "Session"               : 15, # Retrieve session information (changes infrequently)
                "Dynamic"               : 16, # Retrieve dynamic information (changes frequently)
                "Configuration"         : 17, # Retrieve configurable parameter information (only done on request)
                "Complete"              : 18  # Query process is completed for this node
        }

#######################################################################################################################
############# LAUNCH  #################################################################################################
#######################################################################################################################

    def _network_started(self, network):

    # executed once the software representation is started. the discovery of the network components has begun. they will be mapped into objects

        print("network started - %d nodes were found." % network.nodes_count)

    # these dispatchers associate a method to a signal. the signals are generated by the library python-openzwave.
    # a signal may contain a number of parameters that are passed to the method associated to the signal.
    # for exemple, the dispatcher below associates the signal "SIGNAL_NODE_ADDED" to the method "_node_added" that is implemented below (line 111).
    # the signal "SIGNAL_NODE_ADDED" transports two parameters which are the objects network and node.
    # once this signal is received, these two parameters will be passed to the method "_node_added" and the method will be executed.

        dispatcher.connect(self._node_added, ZWaveNetwork.SIGNAL_NODE_ADDED)
        dispatcher.connect(self._node_removed, ZWaveNetwork.SIGNAL_NODE_REMOVED)




    def _network_ready(self, network):

    # executed once the software representation is ready

        print("network : ready : %d nodes were found." % network.nodes_count)
        print("network : controller is : %s" % network.controller)
        dispatcher.connect(self._value_update, ZWaveNetwork.SIGNAL_VALUE)

    def _node_added(self, network, node):

    # executed when node is added to the software representation. it's executed after the method "_debug_node_new" (see below)

        print('node added: %s.' % node.node_id)
        self.timestamps["timestamp" + str(node.node_id)] = "None"
        self.node_added = True

    def _node_removed(self, network, node):

    # executed when node is removed from the software representation

        print('node removed: %s.' % node.name)
        self.node_removed = True


    def _value_update(self, network, node, value):

    # executed when a new value from a node is received

        print('Node %s: value update: %s is %s.' % (node.node_id, value.label, value.data))
        self.timestamps["timestamp" + str(node.node_id)] = int(time.time())




################################################################################################################
######################## START AND STOP THE SOFTWARE REPRESENTATION ############################################
################################################################################################################

    def start(self):

    # this method starts the software representation
        global started


        if started:
            print "Already started"
            return
        started = True
        self.network.start()
        print "Z-Wave Network Starting..."
        for i in range(0, 300):
            if self.network.state == self.network.STATE_READY:
                break
            else:
                time.sleep(1.0)
        if not self.network.is_ready:
            print "Network is not ready but continue anyway"
        print "------------------------------------------------------------"
        print "Nodes in network : %s" % self.network.nodes_count
        print "------------------------------------------------------------"

    def stop(self):

    # this method stops the software representation

        global started
        started = False
        print "Stopping Z-Wave Network... "
        self.network.stop()

    def reset(self):
        if self.network.nodes_count == 1:
            self.network.controller.hard_reset()
            return "Hard Reset Done"
        return "Cannot make Hard Reset while nodes included in network"




#########################################################################################################################
############## YOUR WORK STARTS HERE ####################################################################################
#########################################################################################################################
#########################################################################################################################




#######################################################################################################################
############# NETWORK #################################################################################################
#######################################################################################################################


    def network_info(self):

        #### COMPLETE THIS METHOD ##############
        result = {
            "home_id": self.network.home_id_str,
            "nodes": [self._node_as_obj(node) for i, node in self.network.nodes.items()]
        }

        return json.dumps(result)




#######################################################################################################################
############# NODES #################################################################################################
#######################################################################################################################

    def _node_as_obj(self, node):

        stage = node.getNodeQueryStage
        stagePercent = -1

        if stage in self.queryStages:
            stageNbr = self.queryStages[stage]
            stagePercent = (stageNbr/18.0) * 100

        return {
            "is_ready": node.isReady,
            "neighbours": len(node.neighbors),
            "node_id": node.node_id,
            "node_location": node.location,
            "node_name": node.name,
            "product_name": node.product_name,
            "query_stage": node.getNodeQueryStage,
            "query_stage_percent": stagePercent
        }


    def ordered_nodes_dict(self):

    # returns an ordered list of the network's nodes sorted by node's id

        return OrderedDict(sorted(self.network.nodes.items()))



    def addNode(self):

        #### COMPLETE THIS METHOD ##############
        ctrl = self.network.controller
        timeStop = time.time() + 20
        self.node_added = False 

        if not ctrl.add_node(False):
            return jsonify(error = "could not set the controller in inclusion mode"), 500

        while (time.time() < timeStop):
            if self.node_added: # TODO: should wait for 20s
                self.node_added = False
                return jsonify(info = "Node added successfully")

        return jsonify(info = "Controller in inclusion mode, but no node detected.")



    def removeNode(self):

        #### COMPLETE THIS METHOD ##############
        ctrl = self.network.controller
        timeStop = time.time() + 20
        elf.node_removed = False
        if not ctrl.remove_node(False):
            return jsonify(error = "could not set the controller in exclusion mode"), 500
        while (time.time() < timeStop):
            if self.node_removed:
                elf.node_removed = False
                return jsonify(info = "Node removed successfully")
         return jsonify(info = "Controller in exclusion mode, but no event detected.")


    def get_nodes_list(self):
        #### COMPLETE THIS METHOD ##############
        return json.dumps([self._node_as_obj(node) for node in self.network.nodes.values()])


    def get_node_location(self, n):
        #### COMPLETE THIS METHOD ##############
        if n in self.network.nodes.keys():
            node = self.network.nodes[n]
            return jsonify(node_id = node.node_id, location = node.location)
        return jsonify(error = "node not found"), 404


    def get_node_name(self, n):
        #### COMPLETE THIS METHOD ##############
        if n in self.network.nodes.keys():
            node = self.network.nodes[n]
            return jsonify(id = node.node_id, name = node.name)
        return jsonify(error = "node not found"), 404


    def set_node_name(self, n, value):
        return self._set_field(n, 'name', value)

    def set_node_location(self, n, value):
        return self._set_field(n, 'location', value)


    def _set_field(self, n, field, value):
        if n in self.network.nodes.keys():
            node = self.network.nodes[n]
            node.set_field(field, value)
            return jsonify(node_id = n, value = node.to_dict()[field])

        return jsonify(error = "This node does not exist"), 400



    def get_neighbours_list(self, n):
        result = [self._node_as_obj(self.network.nodes[i]) for i in self.network.nodes[n].neighbors]
        return json.dumps(result)



    def set_node_config_parameter(self, n, param, value, size):

        #### COMPLETE THIS METHOD ##############

        return "this method sets a configuration parameter to a given value"



    def get_node_config_parameter(self, n, param):

        #### COMPLETE THIS METHOD ##############

     return "this method gets the value of a configuration parameter"



    def get_nodes_Configuration(self):

        #### COMPLETE THIS METHOD ##############

        return "this method returns a JSON that gives an overview of the network and it's nodes' configuration parameters (like the ID, Wake-up Interval, Group 1 Reports, Group 1 Interval ...)"



#######################################################################################################################
############# Multisensors #################################################################################################
#######################################################################################################################

class Backend_with_sensors(Backend):

    def get_sensors_list(self):
        #### COMPLETE THIS METHOD ##############
        sensors = [self._node_as_obj(node) for node in self.network.nodes.values() if node.node_id != self.network.controller.node_id]
        return json.dumps(sensors)



    def get_temperature(self, n):

        #### HERE'S AN EXAMPLE OF A METHOD THAT GETS THE TEMPERATURE OF A SPECIFIC SENSOR NODE ##############

        for node in self.network.nodes.itervalues():
            if node.node_id == n and node.isReady and n != 1 and "timestamp"+str(node.node_id) in self.timestamps:
                values = node.get_values(0x31, "User", "All", True, False)
                for value in values.itervalues():
                    if value.label == "Temperature":
                        val = round(value.data,1)
                #        if len(node.location) < 3:
                #            node.location = configpi.sensors[str(node.node_id)][:4]
                        return jsonify(controller = name, sensor = node.node_id, location = node.location, type = value.label.lower(), updateTime = self.timestamps["timestamp"+str(node.node_id)], value = val)
        return jsonify( error = "Node not ready or wrong sensor node !")



    def get_humidity(self, n):

         #### HERE'S AN EXAMPLE OF A METHOD THAT GETS THE HUMIDITY OF A SPECIFIC SENSOR NODE ##############

        for node in self.network.nodes.itervalues():
            if node.node_id == n and node.isReady and n != 1 and "timestamp"+str(node.node_id) in self.timestamps:
                values = node.get_values(0x31, "User", "All", True, False)
                for value in values.itervalues():
                    if value.label == "Relative Humidity":
                        val = int(value.data)
                 #       if len(node.location) < 3:
                 #           node.location = configpi.sensors[str(node.node_id)][:4]
                        return jsonify(controller = name, sensor = node.node_id, location = node.location, type = value.label.lower(), updateTime = self.timestamps["timestamp"+str(node.node_id)], value = val)

        return jsonify(error = "Node not ready or wrong sensor node !")


    def get_luminance(self, n):
        return self.get_xx(n, 'Luminance')


    def get_motion(self, n):
        return self.get_xx(n, 'Burglar')


    def get_battery(self, n):
        return self.get_xx(n, 'Battery Level')


    def get_all_Measures(self, n):
        if not n in self.network.nodes.keys():
            return jsonify(error = "this node does not exist"), 400

        node = self.network.nodes[n]
        values = node.get_values("All", "User", "All", "All", "All").values()
        all_measures = self._get_values_dict(node).values()

        result = {
            'controller': name,
            'measures': all_measures
        }

        return json.dumps(result)



    def _get_values_dict(self, node):
        values = node.get_values("All", "User", "All", "All", "All").values()
        tuples = [ (v.label.lower(), { 'label': v.label.lower(), 'units': v.units, 'node_id': node.node_id, 'value': v.data })  for v in values ]
        return dict(tuples)


    def get_xx(self, n, label, transform=None):
        #### COMPLETE THIS METHOD ##############
        if not n in self.network.nodes.keys():
            return jsonify(error = "this node does not exist"), 400

        node = self.network.nodes[n]

        if not node.isReady or "timestamp"+str(node.node_id) not in self.timestamps:
            return jsonify(error = "This node is not ready"), 500

        label = label.lower()
        values = self._get_values_dict(node)

        if label.lower() not in values:
            return jsonify(error = "this measure does not exist"), 400

        value = values[label]

        if transform:
            value['value'] = transform(value['value'])

        return jsonify(
            controller = name,
            sensor = node.node_id,
            location = node.location,
            type = label,
            updateTime = self.timestamps["timestamp"+str(node.node_id)],
            value = value['value'])



    def set_basic_nodes_configuration(self, Grp_interval, Grp_reports, Wakeup_interval):

        #### COMPLETE THIS METHOD ##############

        return "this method configures the nodes whit a specific configuration"





###########################################################################################################################
###########################################################################################################################
##################    Dimmers class     ##################################################################################
###########################################################################################################################
###########################################################################################################################

class Backend_with_dimmers(Backend):


    def __init__(self):
        Backend.__init__(self)


    def get_dimmers(self):

        #### COMPLETE THIS METHOD ##############

        results = []
        for node in self.network.nodes.values():
            if node.product_name=='ZE27' :
                results.append(self._node_as_obj(node))


        return json.dumps(results)



    def set_dimmer_level(self, n, level):
        print("set dimmer level PROUT")

        #### COMPLETE THIS METHOD ##############
        if n in self.network.nodes.keys():
            node = self.network.nodes[n]
            vs = [v for v in node.get_values("All","User","All","All").values() if v.label == 'Level']
            if len(vs) == 0 :
                return jsonify(error='Level value not found '), 400
            vs[0].data=level
            return jsonify(node_id = node.node_id, value = level)

        return jsonify(error = "Node not found"), 400




    def get_dimmer_level(self, n):

        #### COMPLETE THIS METHOD ##############
        if not n in self.network.nodes.keys():
            return jsonify(error = "this node does not exist"), 400

        node = self.network.nodes[n]

        if not node.isReady or "timestamp"+str(node.node_id) not in self.timestamps:
            return jsonify(error = "This node is not ready"), 500

        label = 'level'
        values = self._get_values_dict(node)

        if label.lower() not in values:
            return jsonify(error = "this measure does not exist"), 400

        value = values[label]


        return jsonify( node_id = node.node_id, value = value['value'])









###########################################################################################################################
###########################################################################################################################
##########    Dimmers and multisensors class         ######################################## #############################
###########################################################################################################################
###########################################################################################################################

class Backend_with_dimmers_and_sensors(Backend_with_dimmers, Backend_with_sensors): # Cette classe sera utilise dans "flask-main"

    pass


